.. _event-bus:

Event Bus
=========

Concept
-------

There are two source of action triggers in the perspective of manager instances: API requests and events.
While ``ai.backend.gateway`` handles the API requests, the event bus takes care of generation, delivery, and processing of the events.
It is the key component to keep a Backend.AI cluster up and running.
The events may be generated by internal timers (e.g., idle checker), agents (e.g., notification of container termination), and managers (e.g., background tasks).
The events may be processed by arbitrary nodes in the cluster, but currently only manager instances do.
The delivery of events is handled by the Redis service deployed in the Backend.AI cluster.

Example scenarios:

* When an agent starts up and shuts down, it generates ``instance_started`` and ``instance_terminated`` events so that the manager can start/stop checking heartbeat intervals.
  The heartbeats are also events named ``instance_heartbeat``.

* When an agent starts a container, it generates a ``kernel_started`` event.
  Whenever a manager instance receives a ``kernel_started`` event, it checks whether all kernels that belong to the same cluster session have started or not. If so, it fires a ``session_started`` event.

* A background task is executed in a specific manager instance, but the API requests to query background task status may be routed to any manager instance.
  Here the progress updates of background tasks must be visible by all manager instances.
  So all manager instances set up subscribers for ``task_updated``, ``task_done``, ``task_cancelled``, and ``task_failed`` events and translates the stream of these events as :ref:`the background task SSE API <bgtask-sse-api>`.

Event Dispatcher
----------------

Subscriber
~~~~~~~~~~

Regardless of which manager (or even agent) instance produces the event, get the notification.
All manager instances receive the same copy of event messages.

Internally this is implemented using Redis publish-subscribe channels.

Consumer
~~~~~~~~

Regardless of which manager (or even agent) instance produces the event, get the notification.
Only one manager instance receives the event message.

Internally this is implemented using Redis lists, where the Redis daemon wakes up the clients (here, manager instances) blocked at the ``BLPOP`` command in a round-robin fashion.


Producing events
----------------

Any manager instance or agent instance may produce event messages at any time.
The event messages are msgpack-encoded object with the following fields:

.. _event-message:

.. list-table::
   :header-rows: 1

   * - Field Name
     - Description
   * - ``event_name``
     - The name of event in snake_case
   * - ``agent_id``
     - The source node of this event.  For manager instances, it is set to ``"manager"``.
   * - ``args``
     - Additional arguments as a tuple.  Each item must be also serializable as msgpack.

When produced, one copy of the message is published to ``"events.pubsub"`` key of the configured Redis instance, and another copy of the message is appended to ``"events.prodcons"`` key.
As long as there are at least one live manager instance, those keys are fetched immediately.
When there is no manager instance running, the messages will be accumulated in the Redis daemon.
If the manager instances start up again, those pending messages will be delivered to them again.


TODO: event dispatcher API reference


Synchronization
---------------

TODO
